// Package main provides a command-line utility to prepend timestamps to lines of
// text, reading from stdin or a file and emitting to stdout or a file.
package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"os"
	"time"

	"github.com/alexflint/go-arg"
)

// opts represents the command-line configuration for the timestamping CLI.
type opts struct {
	Format string `description:"Timestamp format; accepts Go layouts or 's'/'ms' for elapsed time or ds for time since last line and dms for time since last line (ms)" default:"2006-01-02:15:04:05" required:"true" short:"f" long:"format"`
	Input  string `description:"Optional input file (defaults to stdin)" arg:"positional"`
	Output string `description:"Optional output file (defaults to stdout)" arg:"positional"`
}

// createIO wires up the appropriate reader and writer based on the provided
// paths and returns a cleanup function that closes any opened files.
func createIO(in string, out string) (io.Reader, io.Writer, func() error, error) {
	var inFile = os.Stdin
	var outFile = os.Stdout

	mustClose := [](func() error){}
	if in != "" {
		inFile, err := os.Open(in)
		if err != nil {
			return nil, nil, nil, fmt.Errorf("failed to open input file: %v", err)
		}
		mustClose = append(mustClose, inFile.Close)
	}

	if out != "" {
		outFile, err := os.Create(out)
		if err != nil {
			for _, close := range mustClose {
				if err := close(); err != nil {
					return nil, nil, nil, err
				}
			}
			return nil, nil, nil, fmt.Errorf("failed to open output file: %v", err)
		}
		mustClose = append(mustClose, outFile.Close)
	}

	return inFile, outFile, func() error {
		errs := []error{}
		for _, close := range mustClose {
			if err := close(); err != nil {
				errs = append(errs, err)
			}
		}
		return errors.Join(errs...)
	}, nil
}

// run processes the input stream line by line, prefixing each line with a
// timestamp generated according to the requested format.
func run(args opts) (err error) {
	inFile, outFile, close, err := createIO(args.Input, args.Output)
	if err != nil {
		return err
	}

	defer func() {
		if cerr := close(); cerr != nil && err == nil {
			err = cerr
		}
	}()

	return processLines(inFile, outFile, args.Format, time.Now)
}

// main parses CLI arguments and executes the timestamping workflow.
func main() {
	var args opts
	arg.MustParse(&args)
	if err := run(args); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

// processLines consumes lines from the provided reader, prefixes them with a
// timestamp generated by nowFn, and writes the augmented lines to the writer.
func processLines(reader io.Reader, writer io.Writer, format string, nowFn func() time.Time) error {
	bufreader := bufio.NewReader(reader)
	start := nowFn()
	prev := start

	for {
		line, err := bufreader.ReadString('\n')
		if err != nil && !errors.Is(err, io.EOF) {
			return err
		}

		if len(line) == 0 && errors.Is(err, io.EOF) {
			break
		}

		current := nowFn()
		stamp := formatStamp(format, start, prev, current)
		prev = current
		if _, writeErr := fmt.Fprintf(writer, "%s: %s", stamp, line); writeErr != nil {
			return writeErr
		}

		if errors.Is(err, io.EOF) {
			break
		}
	}

	return nil
}

// formatStamp derives the appropriate timestamp string for the current line.
func formatStamp(format string, start, prev, current time.Time) string {
	switch format {
	case "s":
		diff := current.Sub(start)
		return fmt.Sprintf("%fs", diff.Seconds())
	case "ms":
		diff := current.Sub(start)
		return fmt.Sprintf("%dms", diff.Milliseconds())
	case "ds":
		diff := current.Sub(prev)
		return fmt.Sprintf("%dms", diff.Milliseconds())
	case "dms":
		diff := current.Sub(current)
		return fmt.Sprintf("%dms", diff.Milliseconds())
	default:
		return current.Format(format)
	}
}
