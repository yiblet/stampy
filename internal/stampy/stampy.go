package stampy

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"os"
	"time"
)

// Options captures the configuration used when running the timestamping workflow.
type Options struct {
	Format string
	Input  string
	Output string
}

// Run executes the timestamping workflow using the system clock.
func Run(opts Options) error {
	return RunWithClock(opts, time.Now)
}

// RunWithClock executes the timestamping workflow with a provided clock, making it testable.
func RunWithClock(opts Options, nowFn func() time.Time) (err error) {
	reader, writer, cleanup, err := createIO(opts.Input, opts.Output)
	if err != nil {
		return err
	}

	defer func() {
		if cerr := cleanup(); cerr != nil && err == nil {
			err = cerr
		}
	}()

	return ProcessLines(reader, writer, opts.Format, nowFn)
}

// createIO wires up the appropriate reader and writer based on the provided
// paths and returns a cleanup function that closes any opened files.
func createIO(in string, out string) (io.Reader, io.Writer, func() error, error) {
	var inFile = os.Stdin
	var outFile = os.Stdout

	mustClose := [](func() error){}
	if in != "" {
		f, err := os.Open(in)
		if err != nil {
			return nil, nil, nil, fmt.Errorf("failed to open input file: %v", err)
		}
		inFile = f
		mustClose = append(mustClose, inFile.Close)
	}

	if out != "" {
		f, err := os.Create(out)
		if err != nil {
			for _, close := range mustClose {
				if err := close(); err != nil {
					return nil, nil, nil, err
				}
			}
			return nil, nil, nil, fmt.Errorf("failed to open output file: %v", err)
		}
		outFile = f
		mustClose = append(mustClose, outFile.Close)
	}
	return inFile, outFile, func() error {
		errs := []error{}
		for _, close := range mustClose {
			if err := close(); err != nil {
				errs = append(errs, err)
			}
		}
		return errors.Join(errs...)
	}, nil
}

// ProcessLines consumes lines from the provided reader, prefixes them with a
// timestamp generated by nowFn, and writes the augmented lines to the writer.
func ProcessLines(reader io.Reader, writer io.Writer, format string, nowFn func() time.Time) error {
	bufreader := bufio.NewReader(reader)
	start := nowFn()
	prev := start

	for {
		line, err := bufreader.ReadString('\n')
		if err != nil && !errors.Is(err, io.EOF) {
			return err
		}

		if len(line) == 0 && errors.Is(err, io.EOF) {
			break
		}

		current := nowFn()
		stamp := formatStamp(format, start, prev, current)
		prev = current
		if _, writeErr := fmt.Fprintf(writer, "%s: %s", stamp, line); writeErr != nil {
			return writeErr
		}

		if errors.Is(err, io.EOF) {
			break
		}
	}

	return nil
}

// formatStamp derives the appropriate timestamp string for the current line.
func formatStamp(format string, start, prev, current time.Time) string {
	switch format {
	case "s":
		diff := current.Sub(start)
		return fmt.Sprintf("%fs", diff.Seconds())
	case "ms":
		diff := current.Sub(start)
		return fmt.Sprintf("%dms", diff.Milliseconds())
	case "ds":
		diff := current.Sub(prev)
		return fmt.Sprintf("%dms", diff.Milliseconds())
	case "dms":
		diff := current.Sub(prev)
		return fmt.Sprintf("%dms", diff.Milliseconds())
	default:
		return current.Format(format)
	}
}
